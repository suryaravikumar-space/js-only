/**
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘                                                                              â•‘
 * â•‘         JAVASCRIPT V8 ENGINE - PART 2: PARSING PHASE                         â•‘
 * â•‘                                                                              â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 *
 * â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
 * â•‘  ğŸ¤ 1-2 MINUTE INTERVIEW EXPLANATION                                         â•‘
 * â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
 * â•‘                                                                              â•‘
 * â•‘  "The parsing phase converts source code into a structure V8 can work with. â•‘
 * â•‘  It has two main steps:                                                      â•‘
 * â•‘                                                                              â•‘
 * â•‘  STEP 1 - LEXICAL ANALYSIS (Tokenization):                                   â•‘
 * â•‘  The Lexer reads code character by character and groups them into TOKENS.   â•‘
 * â•‘  For example, `var x = 10;` becomes 5 tokens:                                â•‘
 * â•‘    - KEYWORD: 'var'                                                          â•‘
 * â•‘    - IDENTIFIER: 'x'                                                         â•‘
 * â•‘    - OPERATOR: '='                                                           â•‘
 * â•‘    - NUMBER: '10'                                                            â•‘
 * â•‘    - PUNCTUATOR: ';'                                                         â•‘
 * â•‘                                                                              â•‘
 * â•‘  STEP 2 - SYNTAX ANALYSIS (AST Generation):                                  â•‘
 * â•‘  The Parser takes tokens and builds an Abstract Syntax Tree.                 â•‘
 * â•‘  AST is a tree representing code structure and meaning.                      â•‘
 * â•‘                                                                              â•‘
 * â•‘  For `2 + 3 * 4`, the AST correctly shows * has higher precedence:           â•‘
 * â•‘  The tree structure ensures 3*4 is computed first, then added to 2.         â•‘
 * â•‘                                                                              â•‘
 * â•‘  WHY THIS MATTERS:                                                           â•‘
 * â•‘  - AST handles operator precedence correctly                                 â•‘
 * â•‘  - AST is input for the next stage (Ignition bytecode generation)           â•‘
 * â•‘  - Parsing errors (SyntaxError) are caught at this stage                     â•‘
 * â•‘  - V8 uses 'lazy parsing' - only fully parses code when needed               â•‘
 * â•‘                                                                              â•‘
 * â•‘  Tools like Babel and ESLint work by manipulating ASTs - they parse          â•‘
 * â•‘  your code, transform the tree, then generate new code from it."             â•‘
 * â•‘                                                                              â•‘
 * â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 *
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ 2.1 LEXICAL ANALYSIS (TOKENIZATION)                                          â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 *   The LEXER reads source code CHARACTER BY CHARACTER and groups them
 *   into meaningful chunks called TOKENS.
 *
 *
 *   SOURCE CODE                                TOKENS
 *   â•â•â•â•â•â•â•â•â•â•â•                                â•â•â•â•â•â•
 *
 *   "var name = \"Surya\";"        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *        â”‚                        â”‚ Token 1: KEYWORD     "var"       â”‚
 *        â”‚                        â”‚ Token 2: IDENTIFIER  "name"      â”‚
 *        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚ Token 3: OPERATOR    "="         â”‚
 *                                 â”‚ Token 4: STRING      "Surya"     â”‚
 *                                 â”‚ Token 5: PUNCTUATOR  ";"         â”‚
 *                                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 *
 *   CHARACTER-BY-CHARACTER PROCESS:
 *   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 *   Position:  0   1   2   3   4   5   6   7   8   9  10  11  12  13  14
 *   Character: v   a   r   ' ' n   a   m   e   ' ' =   ' ' "   S   ...
 *              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”€  â”€  â”€  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 *              â”‚              â”‚                â”‚  â”‚  â”‚  â”‚
 *              â”‚              â”‚                â”‚  â”‚  â”‚  â””â”€â”€â–¶ STRING: "Surya"
 *              â”‚              â”‚                â”‚  â”‚  â””â”€â”€â”€â”€â”€â–¶ (skip whitespace)
 *              â”‚              â”‚                â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â–¶ OPERATOR: =
 *              â”‚              â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ (skip whitespace)
 *              â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ IDENTIFIER: name
 *              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶ KEYWORD: var
 *
 *
 *
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ TOKEN TYPES TABLE                                                            â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚ TOKEN TYPE     â”‚ EXAMPLES                                                â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚ KEYWORD        â”‚ var, let, const, function, return, if, else, for,       â”‚
 *   â”‚                â”‚ while, class, new, this, typeof, instanceof, async,     â”‚
 *   â”‚                â”‚ await, import, export, try, catch, throw                â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚ IDENTIFIER     â”‚ myVar, userName, _private, $element, calculateSum       â”‚
 *   â”‚                â”‚ (names you create for variables, functions, etc.)       â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚ LITERAL        â”‚ Numbers: 42, 3.14, 0xFF, 0b1010, 1e10, 123n             â”‚
 *   â”‚                â”‚ Strings: "hello", 'world', `template`                   â”‚
 *   â”‚                â”‚ Boolean: true, false                                    â”‚
 *   â”‚                â”‚ Special: null, undefined                                â”‚
 *   â”‚                â”‚ RegExp:  /pattern/flags                                 â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚ OPERATOR       â”‚ Arithmetic: + - * / % **                                â”‚
 *   â”‚                â”‚ Comparison: == === != !== < > <= >=                     â”‚
 *   â”‚                â”‚ Logical:    && || ! ?? ?.                               â”‚
 *   â”‚                â”‚ Assignment: = += -= *= /= ??=                           â”‚
 *   â”‚                â”‚ Bitwise:    & | ^ ~ << >> >>>                           â”‚
 *   â”‚                â”‚ Other:      ... => typeof instanceof                    â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚ PUNCTUATOR     â”‚ ( ) { } [ ] ; , . :                                     â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚ COMMENT        â”‚ // single line                                          â”‚
 *   â”‚ (discarded)    â”‚ /* multi-line *                                        â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 *
 *
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ 2.2 SYNTAX ANALYSIS (AST GENERATION)                                         â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 *   The PARSER takes tokens and builds an ABSTRACT SYNTAX TREE (AST).
 *   The AST represents the STRUCTURE and MEANING of the code.
 *
 *
 *   TOKENS                                     AST
 *   â•â•â•â•â•â•                                     â•â•â•
 *
 *   [var] [x] [=] [10] [+] [5] [;]                    Program
 *                                                       â”‚
 *          â”‚                                    VariableDeclaration
 *          â”‚                                      (kind: "var")
 *          â”‚                                            â”‚
 *          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶   VariableDeclarator
 *                                                  /         \
 *                                           Identifier    BinaryExpression
 *                                             (x)           (operator: +)
 *                                                            /        \
 *                                                       Literal      Literal
 *                                                        (10)         (5)
 *
 *
 *   WHY AST MATTERS - OPERATOR PRECEDENCE:
 *   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 *
 *   Expression: "2 + 3 * 4"
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚ WITHOUT PROPER AST      â”‚    â”‚ WITH PROPER AST         â”‚
 *   â”‚ (WRONG!)                â”‚    â”‚ (CORRECT!)              â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚                         â”‚    â”‚                         â”‚
 *   â”‚         +               â”‚    â”‚          +              â”‚
 *   â”‚        / \              â”‚    â”‚         / \             â”‚
 *   â”‚       2   3             â”‚    â”‚        2   *            â”‚
 *   â”‚           â”‚             â”‚    â”‚           / \           â”‚
 *   â”‚           * (wrong!)    â”‚    â”‚          3   4          â”‚
 *   â”‚           â”‚             â”‚    â”‚                         â”‚
 *   â”‚           4             â”‚    â”‚                         â”‚
 *   â”‚                         â”‚    â”‚                         â”‚
 *   â”‚ Result: (2+3)*4 = 20    â”‚    â”‚ Result: 2+(3*4) = 14    â”‚
 *   â”‚ WRONG!                  â”‚    â”‚ CORRECT!                â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 *
 *
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ AST NODE TYPES TABLE                                                         â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚ NODE TYPE              â”‚ JAVASCRIPT CODE EXAMPLE                        â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚ Program                â”‚ (Root node - contains all code)                â”‚
 *   â”‚ VariableDeclaration    â”‚ var x = 10; let y = 20; const z = 30;          â”‚
 *   â”‚ FunctionDeclaration    â”‚ function foo() { }                             â”‚
 *   â”‚ ClassDeclaration       â”‚ class MyClass { }                              â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚ Identifier             â”‚ x, myVar, functionName                         â”‚
 *   â”‚ Literal                â”‚ 42, "hello", true, null                        â”‚
 *   â”‚ BinaryExpression       â”‚ a + b, x * y, i < 10                           â”‚
 *   â”‚ UnaryExpression        â”‚ !flag, -num, typeof x                          â”‚
 *   â”‚ AssignmentExpression   â”‚ x = 10, y += 5                                 â”‚
 *   â”‚ CallExpression         â”‚ func(), console.log("hi")                      â”‚
 *   â”‚ MemberExpression       â”‚ obj.prop, arr[0]                               â”‚
 *   â”‚ ArrowFunctionExpressionâ”‚ () => { }, x => x * 2                          â”‚
 *   â”‚ ArrayExpression        â”‚ [1, 2, 3]                                      â”‚
 *   â”‚ ObjectExpression       â”‚ { key: value }                                 â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚ IfStatement            â”‚ if (cond) { } else { }                         â”‚
 *   â”‚ ForStatement           â”‚ for (let i = 0; i < 10; i++) { }               â”‚
 *   â”‚ WhileStatement         â”‚ while (cond) { }                               â”‚
 *   â”‚ ReturnStatement        â”‚ return value;                                  â”‚
 *   â”‚ BlockStatement         â”‚ { statement1; statement2; }                    â”‚
 *   â”‚ TryStatement           â”‚ try { } catch (e) { } finally { }              â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 *
 *
 * â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 * â”‚ OPERATOR PRECEDENCE TABLE                                                    â”‚
 * â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 *   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
 *   â”‚ PRECEDENCE (high)  â”‚ OPERATORS                                      â”‚
 *   â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
 *   â”‚ 21                 â”‚ () grouping                                    â”‚
 *   â”‚ 20                 â”‚ . [] () member/call                            â”‚
 *   â”‚ 17                 â”‚ ! ~ + - typeof void delete (unary)             â”‚
 *   â”‚ 16                 â”‚ **  (exponentiation)                           â”‚
 *   â”‚ 15                 â”‚ * / %                                          â”‚
 *   â”‚ 14                 â”‚ + -                                            â”‚
 *   â”‚ 12                 â”‚ < <= > >= in instanceof                        â”‚
 *   â”‚ 11                 â”‚ == != === !==                                  â”‚
 *   â”‚ 7                  â”‚ &&                                             â”‚
 *   â”‚ 6                  â”‚ ||                                             â”‚
 *   â”‚ 5                  â”‚ ??                                             â”‚
 *   â”‚ 4                  â”‚ ? : (ternary)                                  â”‚
 *   â”‚ 3                  â”‚ = += -= etc (assignment)                       â”‚
 *   â”‚ 1                  â”‚ , (comma)                                      â”‚
 *   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 *
 *
 * RUN: node javaScript-v8-architecture-flow/02-parsing-phase.js
 */

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//                         SIMPLE TOKENIZER DEMO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

console.log('â•'.repeat(70));
console.log('       PART 2: PARSING PHASE - TOKENIZATION & AST');
console.log('â•'.repeat(70));

// Simple tokenizer to demonstrate the concept
function tokenize(code) {
  var tokens = [];
  var current = 0;
  var keywords = ['var', 'let', 'const', 'function', 'return', 'if', 'else'];

  while (current < code.length) {
    var char = code[current];

    // Skip whitespace
    if (/\s/.test(char)) { current++; continue; }

    // Numbers
    if (/[0-9]/.test(char)) {
      var num = '';
      while (/[0-9.]/.test(code[current])) num += code[current++];
      tokens.push({ type: 'NUMBER', value: num });
      continue;
    }

    // Strings
    if (char === '"' || char === "'") {
      var quote = char;
      var str = '';
      current++;
      while (code[current] !== quote) str += code[current++];
      current++;
      tokens.push({ type: 'STRING', value: str });
      continue;
    }

    // Identifiers/Keywords
    if (/[a-zA-Z_$]/.test(char)) {
      var ident = '';
      while (/[a-zA-Z0-9_$]/.test(code[current])) ident += code[current++];
      var type = keywords.includes(ident) ? 'KEYWORD' : 'IDENTIFIER';
      tokens.push({ type: type, value: ident });
      continue;
    }

    // Operators
    if ('=+-*/<>!'.includes(char)) {
      var op = char;
      current++;
      if ('='.includes(code[current])) op += code[current++];
      tokens.push({ type: 'OPERATOR', value: op });
      continue;
    }

    // Punctuators
    if ('(){}[];,.'.includes(char)) {
      tokens.push({ type: 'PUNCTUATOR', value: char });
      current++;
      continue;
    }

    current++;
  }

  return tokens;
}

// Test the tokenizer
console.log('\n1. TOKENIZATION DEMO:');
console.log('â”€'.repeat(40));

var code1 = 'var x = 10;';
console.log('   Code: "' + code1 + '"');
console.log('   Tokens:');
tokenize(code1).forEach(function(t, i) {
  console.log('     ' + (i+1) + '. ' + t.type.padEnd(12) + ' â†’ ' + t.value);
});

console.log('\n2. FUNCTION TOKENIZATION:');
console.log('â”€'.repeat(40));

var code2 = 'function add(a, b) { return a + b; }';
console.log('   Code: "' + code2 + '"');
var tokens2 = tokenize(code2);
console.log('   Total tokens:', tokens2.length);
console.log('   Keywords:', tokens2.filter(t => t.type === 'KEYWORD').map(t => t.value).join(', '));
console.log('   Identifiers:', tokens2.filter(t => t.type === 'IDENTIFIER').map(t => t.value).join(', '));

console.log('\n3. OPERATOR PRECEDENCE DEMO:');
console.log('â”€'.repeat(40));
console.log('   Expression: 2 + 3 * 4');
console.log('   Result:', 2 + 3 * 4, '(* has higher precedence than +)');
console.log('   Expression: (2 + 3) * 4');
console.log('   Result:', (2 + 3) * 4, '(parentheses override precedence)');

console.log('\n' + 'â•'.repeat(70));
console.log('       Read the comments above for complete parsing details!');
console.log('â•'.repeat(70) + '\n');
