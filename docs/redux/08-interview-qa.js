/**
 * TOPIC: Redux Interview Questions & Answers
 *
 * ╔════════════════════════════════════════════════════════╗
 * ║  Top Redux interview questions with concise answers   ║
 * ╚════════════════════════════════════════════════════════╝
 */

console.log('=== REDUX INTERVIEW Q&A ===\n');

// Q1
console.log('Q1: What are the three principles of Redux?');
console.log(`
  1. Single source of truth — one store holds entire state tree
  2. State is read-only — only way to change is dispatching actions
  3. Changes via pure functions — reducers take (state, action) => newState
`);

// Q2
console.log('Q2: What is the difference between Redux and Context API?');
console.log(`
  Context: built-in, simple, re-renders ALL consumers on change.
  Redux: external lib, optimized re-renders (only subscribed),
         middleware, devtools, time-travel. Use Context for
         infrequent updates (theme/auth), Redux for frequent.
`);

// Q3
console.log('Q3: What is a Redux middleware? Give examples.');
console.log(`
  Middleware intercepts dispatched actions between dispatch and reducer.
  Shape: store => next => action => result.
  Examples: redux-thunk (async), redux-saga (side effects),
  redux-logger, RTK's serializableCheck/immutableCheck.
`);

// Q4
console.log('Q4: What is Redux Thunk?');
console.log(`
  Middleware that lets you dispatch functions instead of objects.
  The function receives (dispatch, getState) to do async work.
  RTK's createAsyncThunk wraps this with pending/fulfilled/rejected.
`);

// Q5
console.log('Q5: What is the difference between createSlice and createReducer?');
console.log(`
  createSlice = createReducer + auto-generated action creators + types.
  createReducer only creates the reducer function.
  Always prefer createSlice — it does everything.
`);

// Q6
console.log('Q6: How does Immer work in RTK?');
console.log(`
  Immer creates a "draft" proxy of state. You write mutating code
  (state.value = 5), but Immer produces a new immutable object.
  Only works inside createSlice/createReducer. Never mutate outside.
`);

// Q7
console.log('Q7: What is state normalization? Why use it?');
console.log(`
  Store data like a database: { ids: [], entities: {} }.
  Benefits: O(1) lookup by ID, no duplicated data, easy updates.
  Use createEntityAdapter to auto-generate CRUD reducers + selectors.
`);

// Q8
console.log('Q8: What is RTK Query? How is it different from createAsyncThunk?');
console.log(`
  RTK Query: full data-fetching + caching solution built into RTK.
  Auto-generates hooks, handles loading/error/cache/dedup.
  createAsyncThunk: manual approach — you write reducers + state.
  Use RTK Query for API calls. createAsyncThunk for non-API async.
`);

// Q9
console.log('Q9: Explain useSelector vs useDispatch.');
console.log(`
  useSelector(selectorFn): reads data from Redux store.
  Component re-renders only when selected value changes (strict ===).
  useDispatch(): returns the dispatch function to send actions.

  const count = useSelector(state => state.counter.value);
  const dispatch = useDispatch();
  dispatch(increment());
`);

// Q10
console.log('Q10: How do you handle side effects in Redux?');
console.log(`
  1. Redux Thunk (default in RTK) — dispatch functions for async
  2. createAsyncThunk — structured async with lifecycle actions
  3. RTK Query — declarative API calls with caching
  4. Redux Saga — generator-based, for complex side effects
  5. createListenerMiddleware (RTK) — reactive side effects
`);

// Q11
console.log('Q11: What is createSelector and why use it?');
console.log(`
  createSelector from Reselect (included in RTK) creates memoized
  selectors. Only recomputes when input selectors return new values.
  Prevents expensive re-computation and unnecessary re-renders.
`);

// Q12
console.log('Q12: Redux Toolkit vs plain Redux — what changed?');
console.log(`
  RTK eliminates:
  - Action type constants      → auto-generated by createSlice
  - Action creator functions   → auto-generated by createSlice
  - switch/case reducers       → object notation in createSlice
  - Immutable update spreads   → Immer handles it
  - Store setup boilerplate    → configureStore
  - combineReducers            → configureStore does it
  - Manual middleware setup    → sane defaults included
`);

// Q13
console.log('Q13: Can you use Redux without React?');
console.log(`
  Yes! Redux is framework-agnostic. It works with vanilla JS,
  Angular, Vue, or any other framework. react-redux provides
  the React bindings (Provider, useSelector, useDispatch).
`);

// Q14
console.log('Q14: What is the Redux DevTools Extension?');
console.log(`
  Browser extension that shows:
  - Every dispatched action with payload
  - State before and after each action (diff view)
  - Time-travel debugging (jump to any previous state)
  - Action replay and export/import state
  Enabled by default in RTK's configureStore.
`);

// Q15
console.log('Q15: When should you NOT use Redux?');
console.log(`
  - Small apps with simple state
  - State is local to one component
  - Prototype / MVP stage
  - When Context + useReducer is sufficient
  - When server state is the only concern (use React Query/SWR)
`);

/**
 * RUN: node docs/redux/08-interview-qa.js
 */
